// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
package main // import "github.com/tdewolff/hasher"

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"sort"
	"strings"

	"golang.org/x/tools/go/types"

	_ "golang.org/x/tools/go/gcimporter"
)

var (
	typeName = flag.String("type", "", "type name; must be set")
	fileName = flag.String("file", "", "file name, this file will be OVERWRITTEN and should only contain the type; must be set")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\thasher -type T -file F\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://github.com/tdewolff/parse/cmd/hasher\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("hasher: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeName) == 0 || len(*fileName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	var g Generator
	g.parsePackage(".", *fileName, nil)

	// Print the header and package clause.
	g.Printf("// generated by hasher %s; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("package %s\n\n", g.pkg.name)
	g.generate()

	// Format the output.
	src := g.format()

	// Write to file.
	err := ioutil.WriteFile(*fileName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	typeName string   // Name of the constant type.
	values   []string // Accumulator for constant values of that type.
}

type Package struct {
	dir      string
	name     string
	defs     map[*ast.Ident]types.Object
	file     *File
	typesPkg *types.Package
}

// parsePackage analyzes the single package constructed from the named files.
// If text is non-nil, it is a string to be used instead of the content of the file,
// to be used for testing. parsePackage exits if there is an error.
func (g *Generator) parsePackage(directory string, name string, text interface{}) {
	g.pkg = new(Package)
	fs := token.NewFileSet()

	if !strings.HasSuffix(name, ".go") {
		log.Fatalf("parsing package: %s: has no suffix .go", name)
	}
	astFile, err := parser.ParseFile(fs, name, text, 0)
	if err != nil {
		log.Fatalf("parsing package: %s: %s", name, err)
	}
	file := &File{
		file: astFile,
		pkg:  g.pkg,
	}

	g.pkg.name = astFile.Name.Name
	g.pkg.file = file
	g.pkg.dir = directory
	// Type check the package.
	g.pkg.check(fs, astFile)
}

// check type-checks the package. The package must be OK to proceed.
func (pkg *Package) check(fs *token.FileSet, astFile *ast.File) {
	pkg.defs = make(map[*ast.Ident]types.Object)
	config := types.Config{FakeImportC: true}
	info := &types.Info{
		Defs: pkg.defs,
	}
	typesPkg, err := config.Check(pkg.dir, fs, []*ast.File{astFile}, info)
	if err != nil {
		log.Fatalf("checking package: %s", err)
	}
	pkg.typesPkg = typesPkg
}

// generate produces the String method for the named type.
func (g *Generator) generate() {
	values := []string{}
	file := g.pkg.file
	// Set the state for this run of the walker.
	file.typeName = *typeName
	file.values = nil
	if file.file != nil {
		ast.Inspect(file.file, file.genDecl)
		values = file.values
	}

	if len(values) == 0 {
		log.Fatalf("no values defined for type %s", *typeName)
	}
	sort.Strings(values)
	g.buildHashtable(values)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// genDecl processes one declaration clause.
func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		// We only care about const declarations.
		return true
	}
	// The name of the type of the constants we are declaring.
	// Can change if this is a multi-element declaration.
	typ := ""
	// Loop over the elements of the declaration. Each element is a ValueSpec:
	// a list of names possibly followed by a type, possibly followed by values.
	// If the type and value are both missing, we carry down the type (and value,
	// but the "go/types" package takes care of that).
	for _, spec := range decl.Specs {
		vspec := spec.(*ast.ValueSpec) // Guaranteed to succeed as this is CONST.
		if vspec.Type == nil && len(vspec.Values) > 0 {
			// "X = 1". With no type but a value, the constant is untyped.
			// Skip this vspec and reset the remembered type.
			typ = ""
			continue
		}
		if vspec.Type != nil {
			// "X T". We have a type. Remember it.
			ident, ok := vspec.Type.(*ast.Ident)
			if !ok {
				continue
			}
			typ = ident.Name
		}
		if typ != f.typeName {
			// This is not the type we're looking for.
			continue
		}
		// We now have a list of names (from one line of source code) all being
		// declared with the desired type.
		// Grab their names and actual values and store them in f.values.
		for _, name := range vspec.Names {
			if name.Name == "_" {
				continue
			}
			f.values = append(f.values, name.Name)
		}
	}
	return false
}

// buildMap handles the case where the space is so sparse a map is a reasonable fallback.
// It's a rare situation but has simple code.
func (g *Generator) buildHashtable(all []string) {
	orig := make([]string, len(all))
	copy(orig, all)

	// lowercase first character
	for i, s := range all {
		b := []byte(s)
		if len(b) > 0 {
			b[0] = bytes.ToLower(b[:1])[0]
			for j, x := range b {
				if x == '_' {
					b[j] = '-'
					if len(b) > j+1 {
						b[j+1] = bytes.ToLower(b[j+1 : j+2])[0]
					}
				}
			}
		}
		all[i] = string(b)
	}

	// uniq - lists have dups
	// compute max len too
	maxLen := 0
	w := 0
	for _, s := range all {
		if w == 0 || all[w-1] != s {
			if maxLen < len(s) {
				maxLen = len(s)
			}
			all[w] = s
			w++
		}
	}
	all = all[:w]

	// Find hash that minimizes table size.
	var best *table
	for i := 0; i < 1000000; i++ {
		if best != nil && 1<<(best.k-1) < len(all) {
			break
		}
		h := rand.Uint32()
		for k := uint(0); k <= 16; k++ {
			if best != nil && k >= best.k {
				break
			}
			var t table
			if t.init(h, k, all) {
				best = &t
				break
			}
		}
	}
	if best == nil {
		fmt.Fprintf(os.Stderr, "failed to construct string table\n")
		os.Exit(1)
	}

	layout := append([]string{}, all...)

	// Remove strings that are substrings of other strings
	for changed := true; changed; {
		changed = false
		for i, s := range layout {
			if s == "" {
				continue
			}
			for j, t := range layout {
				if i != j && t != "" && strings.Contains(s, t) {
					changed = true
					layout[j] = ""
				}
			}
		}
	}

	// Join strings where one suffix matches another prefix.
	for {
		// Find best i, j, k such that layout[i][len-k:] == layout[j][:k],
		// maximizing overlap length k.
		besti := -1
		bestj := -1
		bestk := 0
		for i, s := range layout {
			if s == "" {
				continue
			}
			for j, t := range layout {
				if i == j {
					continue
				}
				for k := bestk + 1; k <= len(s) && k <= len(t); k++ {
					if s[len(s)-k:] == t[:k] {
						besti = i
						bestj = j
						bestk = k
					}
				}
			}
		}
		if bestk > 0 {
			layout[besti] += layout[bestj][bestk:]
			layout[bestj] = ""
			continue
		}
		break
	}

	text := strings.Join(layout, "")

	hash := map[string]uint32{}
	for _, s := range all {
		off := strings.Index(text, s)
		if off < 0 {
			panic("lost string " + s)
		}
		hash[s] = uint32(off<<8 | len(s))
	}

	g.Printf("// github.com/tdewolff/hasher\n")
	g.Printf("//go:generate hasher -type=%s -file=%s\n", *typeName, *fileName)
	g.Printf("type %s uint32\n\n", *typeName)
	g.Printf("const (\n")
	for i, s := range all {
		g.Printf("\t%s %s = %#x\n", orig[i], *typeName, hash[s])
	}
	g.Printf(")\n\n")

	g.Printf(stringFunc, *typeName)
	g.Printf(hashFunc, *typeName)
	g.Printf("\nconst _%s_hash0 = %#x\n", *typeName, best.h0)
	g.Printf("const _%s_maxLen = %d\n", *typeName, maxLen)
	g.Printf("const _%s_text =", *typeName)
	for len(text) > 60 {
		g.Printf("\t%q +\n", text[:60])
		text = text[60:]
	}
	g.Printf("\t%q\n\n", text)
	g.Printf("var _%s_table = [1<<%d]%s{\n", *typeName, best.k, *typeName)
	for i, s := range best.tab {
		if s == "" {
			continue
		}
		g.Printf("\t%#x: %#x, // %s\n", i, hash[s], s)
	}
	g.Printf("}\n")
}

const stringFunc = `// String returns the hash' name.
func (i %[1]s) String() string {
	start := uint32(i >> 8)
	n := uint32(i & 0xff)
	if start+n > uint32(len(_%[1]s_text)) {
		return ""
	}
	return _%[1]s_text[start : start+n]
}
`

const hashFunc = `// Hash returns the hash whose name is s. It returns zero if there is no
// such hash. It is case sensitive.
func To%[1]s(s []byte) %[1]s {
	if len(s) == 0 || len(s) > _%[1]s_maxLen {
		return 0
	}
	h := _%[1]s_fnv(s)
	if i := _%[1]s_table[h&uint32(len(_%[1]s_table)-1)]; int(i&0xff) == len(s) && _%[1]s_match(_%[1]s_string(i), s) {
		return i
	}
	if i := _%[1]s_table[(h>>16)&uint32(len(_%[1]s_table)-1)]; int(i&0xff) == len(s) && _%[1]s_match(_%[1]s_string(i), s) {
		return i
	}
	return 0
}

// _%[1]s_fnv computes the FNV hash with an arbitrary starting value h.
func _%[1]s_fnv(s []byte) uint32 {
	h := uint32(_%[1]s_hash0)
	for i := range s {
		h ^= uint32(s[i])
		h *= 16777619
	}
	return h
}

func _%[1]s_match(s string, t []byte) bool {
	for i, c := range t {
		if s[i] != c {
			return false
		}
	}
	return true
}

func _%[1]s_string(i %[1]s) string {
	return _%[1]s_text[i>>8 : i>>8+i&0xff]
}
`

////////////////////////////////////////////////////////////////

type byLen []string

func (x byLen) Less(i, j int) bool { return len(x[i]) > len(x[j]) }
func (x byLen) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
func (x byLen) Len() int           { return len(x) }

// fnv computes the FNV hash with an arbitrary starting value h.
func fnv(h uint32, s string) uint32 {
	for i := 0; i < len(s); i++ {
		h ^= uint32(s[i])
		h *= 16777619
	}
	return h
}

// A table represents an attempt at constructing the lookup table.
// The lookup table uses cuckoo hashing, meaning that each string
// can be found in one of two positions.
type table struct {
	h0   uint32
	k    uint
	mask uint32
	tab  []string
}

// hash returns the two hashes for s.
func (t *table) hash(s string) (h1, h2 uint32) {
	h := fnv(t.h0, s)
	h1 = h & t.mask
	h2 = (h >> 16) & t.mask
	return
}

// init initializes the table with the given parameters.
// h0 is the initial hash value,
// k is the number of bits of hash value to use, and
// x is the list of strings to store in the table.
// init returns false if the table cannot be constructed.
func (t *table) init(h0 uint32, k uint, x []string) bool {
	t.h0 = h0
	t.k = k
	t.tab = make([]string, 1<<k)
	t.mask = 1<<k - 1
	for _, s := range x {
		if !t.insert(s) {
			return false
		}
	}
	return true
}

// insert inserts s in the table.
func (t *table) insert(s string) bool {
	h1, h2 := t.hash(s)
	if t.tab[h1] == "" {
		t.tab[h1] = s
		return true
	}
	if t.tab[h2] == "" {
		t.tab[h2] = s
		return true
	}
	if t.push(h1, 0) {
		t.tab[h1] = s
		return true
	}
	if t.push(h2, 0) {
		t.tab[h2] = s
		return true
	}
	return false
}

// push attempts to push aside the entry in slot i.
func (t *table) push(i uint32, depth int) bool {
	if depth > len(t.tab) {
		return false
	}
	s := t.tab[i]
	h1, h2 := t.hash(s)
	j := h1 + h2 - i
	if t.tab[j] != "" && !t.push(j, depth+1) {
		return false
	}
	t.tab[j] = s
	return true
}
